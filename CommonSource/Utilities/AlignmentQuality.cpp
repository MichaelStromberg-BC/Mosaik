// ***************************************************************************
// CAlignmentQuality - calculates the alignment qualities from a technology-
//                     specific logistic regression model.
// ---------------------------------------------------------------------------
// (c) 2006 - 2009 Michael Strömberg
// Marth Lab, Department of Biology, Boston College
// ---------------------------------------------------------------------------
// Dual licenced under the GNU General Public License 2.0+ license or as
// a commercial license with the Marth Lab.
// ***************************************************************************

#include "AlignmentQuality.h"

// our bias vectors
const float CAlignmentQuality::mB_Illumina[30] = {
	2.169907296074702f, -3.129477735997269f,  -2.371065652237502f,  1.233236522837835f,  0.490670584955776f,  0.249250124927987f, 
	1.389708912178757f, -1.424784061583986f, -10.780196526995761f, -0.130152789237745f, -2.714146233101552f,  0.172998539240451f, 
	1.624826137439819f,  0.385721527889763f,  -0.583008029889737f, -4.375626073014767f,  1.521027678368362f,  0.950978432040734f, 
	-0.325325432679605f, -0.074771274782593f,  -3.821185374021564f, -1.442860267214486f, -0.830303473546100f, -0.346587980073582f, 
	0.016427555114422f,  0.751184346936185f,   2.689483714133262f,  1.157623691304614f,  0.511145778571469f, -1.474408695766435f
};

const float CAlignmentQuality::mB_454[40] = {
	-1.231747008473245f,  4.287264350191941f,  3.190361814720891f, -5.307793324077017f,  0.529635411492342f, -1.244129845725731f, 
	-4.677705771353370f,  1.646901324216274f, -1.149681082432313f, -0.953711450672106f,  0.154901212408090f, -2.058861479176853f, 
	-2.004553569779570f, -3.499703873397518f, -1.310494207795577f, -1.686568547588871f, -0.889444531549140f,  0.382061204793186f, 
	-0.473554254525492f,  1.143754348985718f,  1.099821977670424f,  3.228484999838622f,  1.230868906718722f,  0.200270169130595f, 
	-0.385993839104925f, -4.632140115809730f,  0.181117876674882f, -1.045080659642514f,  7.096467286698779f, -5.392146999180093f, 
	-3.201028873932439f, -1.792412305150058f, -2.330259206646264f, -0.985696314233851f,  5.953072286473598f, -1.808609977215390f, 
	4.065515554311327f, -4.413931285404078f,  3.057687845724772f,  0.489294576748457f
};

// our input weight matrices
const float CAlignmentQuality::mIW_Illumina[30][4] = {
	{ -0.296013246157635f,   1.458330936554055f,  -0.948319624326774f,  -1.835952144423496f },
	{ -0.603142696582703f,  -0.816170834430103f,  -1.814974368038304f,  -0.851042237807000f },
	{  0.507652266840408f,  -2.279201844519786f,   0.194180036246400f,  -2.040236159265272f },
	{ -0.043016458445744f,  -0.010709509582761f,   1.007848356164298f,  -0.644209801414050f },
	{  0.140123353433088f,   0.073374815959603f,   0.377832690623571f,   1.202549159455946f },
	{ -3.862673956081467f,  -0.056453786817668f,  -1.331073957338011f,  -1.829826464601857f },
	{ -0.174805329068405f,  -0.062811737070201f,   1.195297984504568f,  -0.288471707064436f },
	{  1.479571970640148f,   0.085965913104803f,   2.111735156560451f,  -0.605495064388488f },
	{ 14.129521990645495f, -19.155496045745000f,  -9.326130105670908f, -21.050112594417801f },
	{  0.147729232482300f,   0.036983001724554f,  -1.611659145497314f,  -0.341211875968920f },
	{  0.631533846864161f,   4.865131935750250f,   0.808847045048049f,  -4.474018578850546f },
	{ -0.267570159810429f,  -0.028879741277315f,   1.957017639050116f,   0.492784906601063f },
	{  0.717648300061914f,   5.910093034871822f,   0.247565666583272f,  -6.254365066909140f },
	{ -0.639076669847017f,  -0.945917727851020f,  -0.580735307966697f,   2.792639445221756f },
	{  0.017300121372150f,  -0.030906602403814f,   0.244922108446205f,   2.343913447622391f },
	{ -1.880224509453040f,  -3.719439274896399f,  -1.941456002039736f,  -6.650562405288539f },
	{  0.074087101121315f,   0.051327317048572f,  -0.271710183551634f,  -1.813936375706288f },
	{ -0.509886856372402f,   0.130395890883258f,   2.435672725450716f,   2.169436186194684f },
	{  0.859904130022690f,  -0.868723280525871f,  -0.223592151607941f,  -2.511976800200121f },
	{ -0.011115034502238f,   0.089199118930556f,   0.513035609858063f,  -3.409887991708362f },
	{  0.364699180029978f,  -7.920901172966467f,   2.902901561540966f,   5.961693214245349f },
	{ -0.455959689427340f,   0.150264879377452f,  -2.097277600695603f,   1.171858263593779f },
	{ -0.044998163497933f,  -0.026728149169215f,  -0.005226054146608f,   1.420730953210515f },
	{  0.006217799644940f,   0.015081706676565f,   1.382575529038237f,  -0.373651691248444f },
	{  0.662884537141987f,  -0.195990595583276f,  -0.623758907601936f,  -1.292233713924829f },
	{  0.035301965831128f,   0.020785451380435f,   0.667057014379272f,  -0.777139648997427f },
	{ -0.618602249081119f,   2.786539307792352f,  -0.231767341705698f,   2.431642390934069f },
	{  0.064129450181281f,  -0.065089939168049f,  -1.702424819464367f,   1.342970594955642f },
	{  0.272240194948259f,   0.021668268737538f,   0.013838954805861f,   0.927776494332908f },
	{ -0.463014334141554f,  -0.022023086454839f,   1.434423865690653f,   0.413784104911973f }
};

// our input weight matrices
const float CAlignmentQuality::mIW_454[40][4] = {
	{  4.306378016642811f,  0.513353316604695f,  3.400195686639305f,  1.859122279864993f },
	{ -0.696249922173134f,  0.288090593961016f,  5.062124735591704f,  0.374070869368408f },
	{  0.786522982849295f, -0.122302636437523f, -0.144261463101167f, -4.398610433439455f },
	{  0.457146164097094f,  0.303776456706078f,  0.454958658624071f,  6.988896651612909f },
	{ -1.097646273555145f, -0.088595769025064f, -0.714064395221384f,  0.044937835565263f },
	{ -0.313406393172199f,  0.071770592021163f, -1.619048960091731f,  1.531587086520456f },
	{ -0.462579522523995f, -0.592737516723901f, -3.228874440981373f,  1.020195634765465f },
	{  0.633731667101014f, -0.187963707487668f, -2.172930373151053f, -0.648570459740339f },
	{ -0.462156489334429f,  0.030199130593374f, -1.163939677846456f,  2.721062032426834f },
	{ -0.629136773522335f,  0.028622768365596f, -2.235440761109735f, -0.408946640701297f },
	{  0.053304603591062f,  0.015470538164837f,  0.155977007751210f, -4.935363461991232f },
	{  1.975165206208061f, -7.026006450612964f,  0.114754295540949f, -0.184874187452298f },
	{ -3.553142174680784f,  0.063377217586438f, -0.342919551828218f, -0.530420534871842f },
	{ -1.445576914239675f, -4.501591748221568f, -0.591738780391100f,  3.421145490901828f },
	{ -1.353657448890878f,  0.041103236846768f, -1.133927077944315f,  1.659653568635069f },
	{  1.858038814352786f,  0.023608135413402f,  0.707322667958926f, -5.232200358053478f },
	{ -4.501770971043851f, -0.391917304876484f, -0.044818546298442f,  0.714680536904934f },
	{  0.157286331553000f,  0.005830923850428f, -0.034344925456505f, -5.824874894883873f },
	{ -0.006515318735501f,  0.099733246136950f,  1.812454541503738f, -1.015420132790623f },
	{  0.659898549032100f, -0.042791958089718f,  2.201231309132566f,  0.550960158778141f },
	{  0.506523851061182f, -1.237278534767631f,  0.701033686841876f,  0.097254437073916f },
	{  5.133318914957767f, -1.705564708549406f, -0.481632455048675f, -4.335060696732207f },
	{  1.561430213101855f, -0.026602683009515f,  1.025906721377535f, -1.404321752870659f },
	{ -0.258156714185782f, -0.044041939366795f, -1.822607212577933f,  0.655210387794953f },
	{  0.139215711218890f,  0.062634138165045f,  1.759791452626037f, -0.878835201965173f },
	{  0.767700643968641f, -1.314137820789682f,  6.779062972230474f, -5.258540075025875f },
	{  1.655884354215647f, -0.077210975341878f, -0.877077206579370f, -2.105876822531582f },
	{ -0.452511914533535f,  0.036621131009873f, -1.079182237844654f,  2.307524324460872f },
	{  3.493902822462481f, -0.227224309254845f,  2.049993907901795f, -5.836692811873867f },
	{ -0.037898902269642f,  0.263861684371081f,  1.717221374927954f,  5.467163134721855f },
	{ -5.329433657055773f,  0.202235057819513f, -0.327386597664025f, -0.962758385765687f },
	{  1.852463745071195f,  0.027181929216697f,  0.808015570053532f, -5.352841867883749f },
	{ -1.347939409493027f,  0.060198620406589f, -2.322230439195519f,  2.007326274184600f },
	{ -0.475440725593362f,  0.042888330481142f, -0.335554065418235f, -0.534951328064676f },
	{  6.034719207356314f, -1.759707445213206f,  0.191130498431258f, -4.199220705693185f },
	{ -0.638921967770740f,  0.201440651615786f,  2.261426538040822f,  0.556234346493921f },
	{  5.102266263036186f,  1.276069276877410f,  0.259462595854004f, -2.346894481935414f },
	{ -5.571561448090424f, -1.520300577621570f, -0.291041168625525f,  2.566439193384802f },
	{  0.872572495808077f, -0.139384940770698f, -0.339552300902715f, -3.856994705389183f },
	{  1.883875660490122f, -0.074551129566232f, -1.478634802930595f, -2.199175060028601f }
};

// our layer weight matrices
const float CAlignmentQuality::mLW_Illumina[30] = {
	-0.161903927507140f,  0.256329757837460f, -2.097552285390742f, -5.740445473342389f, -1.840463669516174f,  0.024400733530884f, 
	2.090425730128093f,  0.048234471632546f, -0.004962690478952f, -3.174404884348698f, -0.071167962152882f, -1.399087090446132f, 
	-0.030279470374394f, -0.276385481349239f, -2.138480668769014f,  0.025096101069457f,  4.766743362481062f,  0.113735358254038f, 
	-0.197475154211484f, -0.587182628214273f, -0.043076226654152f,  0.219561840295935f,  8.648919106351167f, -3.103921801577223f, 
	0.421557297203566f,  6.285385366562431f, -1.857926277897706f, -1.004631315172715f,  1.692797907583215f,  0.566461588340792f
};

const float CAlignmentQuality::mLW_454[40] = {
	0.030519810553631f, -0.062456684881890f, -1.184065117811757f,  0.090213059833711f,  0.275498930793056f, -0.761412157879041f, 
	0.270933426277992f,  1.186530038016906f, -2.718473163860934f, -1.331353533918998f, -0.502276940182063f, -0.020747842619316f, 
	0.429205359670036f,  0.001672631242224f, -1.700462487208573f, -1.431646001962333f, -0.068368660925474f,  0.432830021755911f, 
	-1.747642520399021f, -1.090145795927761f, -0.048488571897607f,  0.040369413535245f, -1.273510013661434f,  2.943108134123385f, 
	4.502335391021161f, -0.008225826963338f,  0.380807108220415f,  4.094653167166205f,  0.136452612250140f, -0.214391461733372f, 
	-0.268589764805850f,  1.373702745885479f,  0.373438088940087f, -0.816725740515720f,  0.057888526836968f,  1.122388486244052f,
	0.872966544580390f,  0.761958522293173f,  1.232855252863173f, -0.252026240651210f
};

// our mismatch bin boundaries
const double CAlignmentQuality::mMismatchBQBins[21] = {
	0.000001f, 0.000077f, 0.000279f, 0.000691f, 0.001388f, 0.002448f, 0.003952f,
	0.005977f, 0.008606f, 0.011919f, 0.015998f, 0.020925f, 0.026783f, 0.033655f,
	0.041624f, 0.050774f, 0.061190f, 0.072955f, 0.086154f, 0.100874f, 1.000000f
};

// constructor
CAlignmentQuality::CAlignmentQuality(bool usingIllumina, unsigned int refLen)
: mUsingIllumina(usingIllumina)
{
	// convert the reference length to ln(reference length)
	mLnReferenceLength = (float)log((double)refLen);
}

// destructor
CAlignmentQuality::~CAlignmentQuality(void) {}

// calculates the alignment quality
void CAlignmentQuality::CalculateQuality(vector<Alignment>::iterator& alIter) const {

	// initialize
	const char* pReference     = alIter->Reference.CData();
	const char* pQuery         = alIter->Query.CData();
	char* pBaseQualities       = alIter->BaseQualities.Data();

	const unsigned int pairwiseLength   = alIter->Query.Length();

	char* pBaseQualities2 = new char[pairwiseLength + 1];
	pBaseQualities2[pairwiseLength] = 0;

	// =============================================
	// aggregate the gaps in the base quality string
	// =============================================

	const char* pQry = pQuery;
	const char* pBQ  = pBaseQualities;
	char* pBQ2       = pBaseQualities2;
	char prevBQ      = 0;

	while(*pQry) {

		if(*pQry == '-') {

			// count the gap length
			unsigned int gapLength = 0;
			const char* pGap = pQry;
			while(*pGap == '-') {
				pGap++;
				gapLength++;
			}

			// assign the minimum of the flanking base qualities to the gap
			const unsigned char gapBQ = min(prevBQ, *pBQ);
			for(unsigned int j = 0; j < gapLength; ++j, ++pBQ2) *pBQ2 = gapBQ;
			pQry += gapLength - 1;

		} else {

			prevBQ = *pBQ2 = *pBQ;
			++pBQ2;
			++pBQ;
		}

		++pQry;
	}

	// ===========================================
	// calculate the mismatch base quality percent
	// ===========================================

	unsigned int baseQualitySum   = 0;
	unsigned int mmBaseQualitySum = 0;

	unsigned int alleleCounts[4];
	alleleCounts[0] = 0; alleleCounts[1] = 0; alleleCounts[2] = 0; alleleCounts[3] = 0;

	const char* pRef = pReference;
	pQry             = pQuery;
	pBQ2             = pBaseQualities2;

	for(unsigned int i = 0; i < pairwiseLength; ++i, ++pQry, ++pRef, ++pBQ2) {

		// increment the base quality sums
		if(*pQry != *pRef) mmBaseQualitySum += *pBQ2;
		baseQualitySum += *pBQ2;

		// store the allele count
		switch(*pQry) {
			case 'A':
				alleleCounts[0]++;
				break;
			case 'C':
				alleleCounts[1]++;
				break;
			case 'G':
				alleleCounts[2]++;
				break;
			case 'T':
				alleleCounts[3]++;
				break;
		}
	}

	// calculate the mismatch base quality percentage
	double mmBaseQualityPercent = (double)mmBaseQualitySum / (double)baseQualitySum;

	// identify the correct mismatch base quality bin
	float mmbqBin = 0.0f;
	for(unsigned char j = 0; j < NUM_MMBQ_BINS; ++j) {
		if(mmBaseQualityPercent < mMismatchBQBins[j]) {
			mmbqBin = (float)j;
			break;
		}
	}

	// free some memory
	delete [] pBaseQualities2;

	// =================================
	// calculate the information content
	// =================================

	const unsigned int numAlleleCounts = alleleCounts[0] + alleleCounts[1] + alleleCounts[2] + alleleCounts[3];

	float informationContent = 0.0f;
	for(unsigned char i = 0; i < 4; i++) {
		if(alleleCounts[i] == 0) continue;
		const float alleleFreq = alleleCounts[i] / (float)numAlleleCounts;
		informationContent += -1.442695040888963f * alleleFreq * log(alleleFreq);
	}
	informationContent *= 10.0f;

	// calculate ln(read length)
	float lnReadLength      = (float)log((double)pairwiseLength);
	float lnReferenceLength = mLnReferenceLength;

	// =======================================================
	// calculate the alignment quality with the neural network
	// =======================================================

	// preprocess the input pattern
	Normalize(informationContent, mmbqBin, lnReadLength, lnReferenceLength);

	// calculate y1 and y2
	float y1;
	float y2 = 0.0f;

	if(mUsingIllumina) { // ILLUMINA

		for(unsigned int i = 0; i < 30; i++) {
			y1 = 2.0f / (1.0f + exp(-2.0f * (mIW_Illumina[i][0] * lnReadLength + mIW_Illumina[i][1] * lnReferenceLength + mIW_Illumina[i][2] *
				mmbqBin + mIW_Illumina[i][3] * informationContent + mB_Illumina[i]))) - 1.0f;
			y2 += mLW_Illumina[i] * y1;
		}

		y2 += LAYER_BIAS_ILLUMINA;

	} else { // 454

		for(unsigned int i = 0; i < 40; i++) {
			y1 = 2.0f / (1.0f + exp(-2.0f * (mIW_454[i][0] * lnReadLength + mIW_454[i][1] * lnReferenceLength + mIW_454[i][2] *
				mmbqBin + mIW_454[i][3] * informationContent + mB_454[i]))) - 1.0f;
			y2 += mLW_454[i] * y1;
		}

		y2 += LAYER_BIAS_454;
	}

	// denormalize the output pattern
	alIter->Quality = Denormalize(y2);
}
